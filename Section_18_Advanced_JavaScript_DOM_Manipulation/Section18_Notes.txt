# Section 18: Advanced JavaScript and DOM Manipulation:


## 134. What We'll Make: Drum Kit:


In order to learn about some of the more intermediate/advanced parts of the Document Object Model, we'll be building a DrumKit website.
By the end of this module, we'll learn how to add event listeners to buttons and keystrokes to know when a user is typing on their keyboard or 
clicking on a particular button on your website and you can respond to it.
The website basically is a number of buttons that are linked to various drum sounds that can either be clicked or are also linked to certain keyboard key presses.


## 135. Download the Starting Files:


This lesson contains the starting files for getting this program running.
HTML and CSS completed, but empty JS file.
Went ahead and re-typed the HTML and CSS to get a look at the inner workings of this project.
    Made a few custom changes based on personal taste.


## 136. Adding Event LIsteners to a Button:


With all 3 files for this project open, we first need to link the js file to the html file.
    Remember that script uses a source, not an href.
Currently, even though we have all these buttons on the page, nothing happens when we click any of them.
    To start registering the button clicks, we need to add what we call an Event Listener to it.
    With that set up, the buttons will then tell us when a user clicks on one of them.
Before setting the listeners up, let's first create a function in the js file to be executed when the button gets clicked.
    The idea being for this function to be called whenever a button gets clicked.
In order to do this, we have to select the button in the HTML and add an event listener to it.
    We'll add an event listener with the following code:
                document.querySelector("button").addEventListener()
    For now, we're only targeting the first button to see how this works.
If we at the documentation for this event listener method, we'll see that this method sets up a function to be called whenever the 
    specified event is delivered to the target.
    I.e: A set function is called when a configured event occurs on the object in question.
The event listener method has 2 parameters:
    The first one being the type, which is a case-sensitive string representing the event type to listen to.
    The second one being the listener, which is usually a JS function that's called when the event gets detected.
Adding these parameters to the code:
                document.querySelector("button").addEventListener("click", handleClick);
    So now the first button (the W button) listens for whenever it gets clicked, and then the function gets called.
Now, once the button is clicked, we'll get an alert notifying us of this (because it's just an alert set up in the button right now.)
Now an important note here is that the function call in the event listener doesn't have the brackets anymore.
    Now if we included the set of brackets like a normal call, the function would run on its own on page reload every time.
    Without clicking the button.
This problem happens because as the code is all running, when it hits the event listener line, if the brakcets are there, it's considered an immediate function call when adding the event listener.
    This isn't the behavior we want, we want it to trigger on-click.
So instead of calling our function, we're just passing the name of the function as an input.
    This means we wait for the click event to happen before the function ever does get called.
This passing of a function as an input is common in JavaScript and will see it regularly.
There are other ways that we'll see this function passing being done.
    The most common one being, instead of writing a function name here that calls the function later on, 
    people simply write the code as an anonymous function.
Anonymous functions look just like normal functions, but they're just anonymous.
    They don't have a name and would look like this:
                    document.querySelector("button").addEventListener("click", function() {
                        window.alert("A button was clicked.");
                    });
Lesson challenge: figure out the efficient way of adding an event listener to each of the buttons.
Solution: using a loop to allow us to fetch a list of all buttons using querySelectorAll, and looping through each button to add a listener.
    Note this is risky because if we added another button later on, the button would catch that too.
    So ideally, we'd use the .drum class applied to all the drum buttons.


## 137. Higher Order Functions and Passing Functions as Arguments:


Let's have a look at how this addEventListener method works.
If we open up a page, for example, the JavaScript wiki page, select the title and inspect it, we'll see there that the h1 can be accessed in the console using a value "$0".
    And if we go into the console and enter this value, we see we get the h1 element returned to us in the console.
    Meaning the $0 value is bound to the h1 value.
Currently, the h1 is not bound to anything.
    But let's try to add an event listener to this h1:
            $0.addEventListener("click", function(){
                console.log("I got clicked");
            });
    Now the h1 has an event listener that outputs the anonymous function every time we click it.
So we've seen we can either use an anonymmous function or specify a named function as the 2nd value for the addEventListener method.
Now from what we've seen, the addEventListener method is different from all other functions that we've seen so far because instead of just passing simple data types,
    we're passing in a function as an input.
Now we can't look at the code that Chrome uses to implement addEventListener because we didn't write that method.
So instead, let's try and create both sides of the coin and in the process we can better understand how addEventListener works.
Let's say we want to create a calculator:
            function calculator(num1, num2) {
                return num1 + num2;
            }
    If we wanted to call the function we'd do it like this:
            calculator(2, 3); //output 5
If we wanted to change the calculator, so instead of adding, we want to multiply.
    We'd have to change the function to make that change.
This is painful and we'd want to be able to specify on the fly what operation we want to execute without needing to manually change it each time.
    What if we created a function that was called add, that took 2 inputs and added them.
            function add(num1, num2) {
                return num1 + num2;
            }
    Then we create another for multiply:
            function multiply(num1, num2) {
                return num1 * num2;
            }
Now with these 2 functions, we want to create a function called calculator that allows us to choose which function we want to run.
    This is a case where being able to pass in a function as an input to another function becomes really handy.
So say we create the calculator function again, but now it takes the 2 numbers, as well as an operator input:
            function calculator(num1, num2, operator){
                return operator(num1, num2);
            }
    This operator input can be changed on the fly when calling this calculator function.
    Then when the function is called, we call the operator function and pass in the 2 numbers and return that function's output.
Now to call this function:
            calculator(4, 5, add);
    Now the third input we need to give this function is the name of another function as we can see that it calls this function inside.
This way, whether add or multiply, we simply provide the name of the function and it'll call the appropriate funciton provided by the user on the fly to get the correct answer.
Once the code gets into the body of the function, it's going ot output whichever function was passed in as the operator input.
    Then it calls that function and passes in the 2 numbers provided and returns that function output.
An available feature in the CDT is called the Debugger.
    If you type into the console:
            debugger;
    And then hold shift+Enter (new line without code execute), then call the function that you want to debug.
    Then run the code, we then enter debug mode.
What you can do in debug mode, is you can step through all of the steps that the browser goes through to give you your final output.
Normally this is used when you're trying to figure out what's going wrong in your code, because instead of playing computer in your head, it's better to actually look at what's happening.
On the right side on the screen is a number of symbols, and the down arrow let's you go to the next step in the code.
    This allows you to do a step-by-step run of the code to see what the browser is doing.
Note that when an input is a function, it's denoted by:
            "inputName = f funcName(input1, input 2)"
    Note that this is not a function call or declaration, it simply equals or points to the existing, declared function.
Now these functions like the one we created, that can take other functiosn as inputs are called:
            "Higher Order Functions"
    This feature is availble in a number of modern languages, but it's not available in all languages.
But it is something we're going to heavily rely on in JS as we learn to manipulate the DOM and give our websites more and more behavior.
Lesson Challenge:
    Create a full set of operators for the calculator.
    That includes +, -, /, *.
    Use the existing calculator function.
    So just need a - and / funciton.


## 138. Higher Order Function Challenge Solution:


This lesson provides the solution code to the lesson challenge at the end of lesson 137.
The challenge was completed successfully.


## 139. How to Play Sounds on a Website:


In this lesson, we're going to expand on the previous lesson, and play the sound of a drum instead of giving an alert on a click event.
If we google it and look at the first StackOverflow answer, we get the following:
                var audio = new Audio('audio_file.mp3');
                audio.play();
    Which is to create a new Audio object, providing the audio file you want to play.
    Then you use the play method of that audio object you created.
So let's test it out now.
    We'll delete the alert to start.
    Then note all sounds are in the assets/sounds folder path.
Lesson Challenge 1:
    Implement the above code in the function linked to the click event for each button.
    Completed easily.
Now we'll often come across helpful code snippets provided by other programmers in StackOverflow.
    But it's important that you fully understand the code if you're going to implement it in your own code.
So searching for the new Audio Javascrip code will give us a result for the HTMLMediaElement.
    The code we're writing effectively creates this element behind the scenes.
    This element has a large number of properties, but the object has a number of methods as well.
        One of which is the play() method, which plays back the media.
Currently, all buttons link to the same sound, but in the sounds and images files, there are a number of corresponding sounds and images.
Challenge 2:
    Inside the styles.css file, used the images to set a background-image for each of the buttons.
    Completed using background-image and background-size properties to set image and fit it to size.
Note that background-image requires the url() as we're setting it to the image relative path url.
Now the next challenge is on how to get each button to have it's own unique sound.
    Naturally, we know that we can fetch the textContent of any of the buttons, and each has a different letter associated with it.
    So we could use that to differentiate the buttons, so when the user presses a button, we get the character the button contains, and 
    then use that to determine which sound we're going to play.
Now in the anonymous function, we need to know which button got clicked so that we can play the right sound.
    Meaning we just need to know which button triggered the event.
    We can do this using the keyword "this"
        The "this" keyword, basically refers to the identity of the button that triggered the event listener.
    If we console.log(this); on the event, we'll see the button element in question being returned.
With access to this object, we can now use the other properties such as textContent to see which button it is we're working with.
We can use this identity to change the style of the button as well.
Lesson Challenge 3:
    On click, change the text colour of the clicked button to white.
    Done via: this.style.color = 'white';


## 140. How to Use Switch Elements in JavaScript:


Now that we're able to tell which key was presed and how we can get its textContent, we need to think about how to play a different sound based on the key.
Now first thought would be for if-else statements, but there are 7 keys/sounds in total.
In scenarios like this, what would be easier would be a "switch statement".
    In these statements, different code gets executed depending on the value of a variable.
Looking at the skeleton of a switch statement:
                switch (expression) {
                    case expression:

                        break;
                    default:

                }
    It starts with the switch keyword that initializes the switch statement.
    After is a set of brackets that'll contain an expression, the thing that we're switching on.
        In our case, it'll be the letter in the textContent of the button.
            Which we'll store in a variable
    Next is the case and it's expression that the switch expression must equal for it to do something in that case.
    After the first case is done, it's followed by a "break;" statement, which tells the code to exit the switch.
    If the first case isn't triggered, then it'll move on to check against the next case.
Note that instead of the curly brackets, the switch case code blocks are denoted by a : and a break;
    The functionality is fundamentally the same as a set of curly brackets however.
Finally in the case, is the default case.
    It's like the else statement at the end of an if.
    It covers all other scenarios not not specified in the cases.
        This is when the default will trigger.
    It'll more than likely never trigger, but it's good practice to include it.
With this switch implemented, each button now maps to a different sound.


## 141. A Deeper Understanding of JavaScript Objects:


